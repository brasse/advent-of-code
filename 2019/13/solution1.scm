(use-modules (ice-9 rdelim))

(define (problem-input)
  (map string->number (string-split (read-line) #\,)))

(define (digit i n)
  (modulo (quotient i (expt 10 n)) 10))

(define (opcode i)
  (modulo i 100))

(define (make-memory-map program)
  (let ((memory (make-hash-table)))
    (for-each
     (lambda (i j)
       (hash-set! memory i j))
     (iota (length program)) program)
    memory))

(define (make-computer program input)
  (let ((memory (make-memory-map program))
        (p 0)
        (rel-base 0)
        (output '()))
    (lambda ()
      (let*
          ((rmem (lambda (addr)
                   (hash-ref memory addr 0)))
           (wmem (lambda (addr x) (hash-set! memory addr x)))
           (imm (lambda (n)
                  (+ p n)))
           (pos (lambda (n)
                  (rmem (+ p n))))
           (rel (lambda (n)
                  (+ rel-base (rmem (+ p n)))))
           (mode (lambda (i n)
                   (case (digit i n)
                     ((0) pos)
                     ((1) imm)
                     ((2) rel))))
           (w (lambda (i n value)
                (wmem ((mode i (1+ n)) n) value)))
           (r (lambda (i n)
                (rmem ((mode i (1+ n)) n)))))
        (set! output '())
        (while #t
          (let ((i (rmem p)))
            (case (opcode i)
              ((1)
               (w i 3 (+ (r i 1) (r i 2)))
               (set! p (+ p 4)))
              ((2)
               (w i 3 (* (r i 1) (r i 2)))
               (set! p (+ p 4)))
              ((3)
               (w i 1 (input))
               (set! p (+ p 2)))
              ((4)
               (set! output (r i 1))
               (set! p (+ p 2))
               (break))
              ((5)
               (if (not (zero? (r i 1)))
                   (set! p (r i 2))
                   (set! p (+ p 3))))
              ((6)
               (if (zero? (r i 1))
                   (set! p (r i 2))
                   (set! p (+ p 3))))
              ((7)
               (if (< (r i 1) (r i 2))
                   (w i 3 1)
                   (w i 3 0))
               (set! p (+ p 4)))
              ((8)
               (if (= (r i 1) (r i 2))
                   (w i 3 1)
                   (w i 3 0))
               (set! p (+ p 4)))
              ((9)
               (set! rel-base (+ rel-base (r i 1)))
               (set! p (+ p 2)))
              ((99) (break)))
            ))
        output))))

(let* ((program (problem-input))
       (computer (make-computer program (const 1)))
       (screen (make-hash-table)))

  ;; Run program
  (while #t
    (let ((x (computer))
          (y (computer))
          (tile-id (computer)))
      (if (null? x)
          (break))
      (hash-set! screen (cons x y) tile-id)))

  ;; Count tiles with block tiles, i.e. tiles with tile-id 2.
  (format #t "~a~%" (hash-count (lambda (k v) (= v 2)) screen)))
